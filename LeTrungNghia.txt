Le Trung Nghia - USTHBI5-098

-----------------> IS Assigment Results <-----------------

--------------> Code was written in Matlab <-------------

********************************************* Assigment 1: A5/1 Cipher ***************************************************

------------------------------------------->> Function: A51Cipher.m <<---------------------------------------------------

% LTNghia
% This is the implementation of A5/1 Key generation algorithm.

function A51Cipher(X,Y,Z)
for n = 1:10
    if n == 1 % calculate 1st keystream bit
        s = bitxor(bitxor(X(19),Y(22)),Z(23));
        fprintf('Keystream bit generated at first: s = %d\n',s) 
    else
        
        % Determine m = maj(x8,y10,z10)
        maj = [X(9) Y(11) Z(11)];
        m = mode(maj);
        
        % Decide whether or not X,Y or Z will step
        if X(9) == m % if x8 = m -> X steps
            t1 = bitxor(bitxor(X(14),X(17)),bitxor(X(18),X(19)));
            for j = 19:-1:2
                X(j) = X(j-1); % shift
            end            
            X(1) = t1; % re-assign value of x0 
        end
        if Y(11) == m % if y10 = m -> Y steps
            t2 = bitxor(Y(21),Y(22));
            for j = 22:-1:2         
                Y(j) = Y(j-1); % shift
            end
            Y(1) = t2; % re-assign value of y0
        end
        if Z(11) == m % if z10 = m -> Z steps
            t3 = bitxor(bitxor(Z(8),Z(21)),bitxor(Z(22),Z(23)));
            for j = 23:-1:2
                Z(j)=Z(j-1); % shift
            end            
            Z(1) = t3; % re-assign value of z0
        end
        
        % Keystream bit generated at n
        s = bitxor(bitxor(X(19),Y(22)),Z(23));
        fprintf('Keystream bit generated at n = %d: s = %d\n',n,s)
    end
end
end

------------------------------------------>> Script: assigment1script.m <<-------------------------------------------------

% LTNghia

clc;

disp('------> This is a script to calculate keystream bits generated by A5/1 Cipher <------')

% X = 1010101010101010101
X = input('\nEnter values of register X: ','s');
X = X - '0';

% Y = 1100110011001100110011
Y = input('Enter values of register Y: ','s');
Y = Y - '0';

% Z = 11100001111000011110000
Z = input('Enter values of register Z: ','s');
Z = Z - '0';

A51Cipher(X,Y,Z)



************************************** Assigment 2: Square-and-multiply algorithm ****************************************

------------------------------------------->> Function: ModuloWithSaM.m <<------------------------------------------------

% LTNghia
% This is the function to calculate modulo using square-and-multiply
% algorithm

function y = ModuloWithSaM(x,e,n)

% Convert exponent from decimal to binary 
h = dec2bin(e);

t = 0;
% Read the binary from MSB (most significant bit)
% to LSB (less significant bit) (from left to right)
for j = 1:length(h)
    if (h(j) == '1') % skip all MSB = '0'
        t = length(h)-j+1; % t = new length start from MSB = '1'
        break;
    end
end

% Initialize r 
r = 1; % e = 0 -> x^0 = 1

for i = (t-1):-1:0 % scan exponent bits
   if (h(t-i) == '1') % if bit processed = '1'
        r = mod((r * r * x), n); % square and multiply
   else % if bit processed = '0'
        r = mod((r * r), n); % square
   end
end

% Return y
y = r;
end

----------------------------------------------->> assigment2script.m <<---------------------------------------------------

% LTNghia

clc;

disp('------> This is a script to calculate x^e mod n using square-and-multiply algorithm <------')
x = input('\nEnter the value of x: ');
e = input('Enter the value of e: ');
n = input('Enter the value of n: ');
fprintf('\nThe result is: %d^%d mod %d = %d\n',x,e,n,ModuloWithSaM(x,e,n))



************************************************* Assigment 3: RSA *******************************************************

----------------------------------------->> Function: RSAEncryptionWithe.m <<---------------------------------------------

% LTNghia
% This is the function using RSA to calculate encryption if p,q,M and e is
% given

function RSAEncryptionWithe(M,p,q,e)
N = p*q;
n = (p-1)*(q-1);
for i = 0:n
    if mod(e*i,n) == 1 % calculate the value of d so that e*d = 1 mod n
        d = i;
        break;
    end
end
fprintf('--> Public key: (N,e) = (%d,%d)\n',N,e);
fprintf('--> Private key: d = %d\n',d);

% The exceeds of maximum integer that is guaranteed to be
% represented exactly as double (which is 2^53) can cause the incorrect result of
% Matlab mod() function -> Apply square-and-multiply algorithm to
% calculate modulo
fprintf('--> Encrypted ciphertext C of plaintext M = %d : C = %d\n',M,ModuloWithSaM(M,e,N));


----------------------------------------->> Function: RSAEncryptionWithd.m <<---------------------------------------------

% LTNghia
% This is the function using RSA to calculate encryption if p,q,M and d is
% given

function RSAEncryptionWithd(M,p,q,d)
N = p*q;
n = (p-1)*(q-1);
for i = 0:n
    if mod(d*i,n) == 1 % calculate the value of e so that e*d = 1 mod n
        e = i;
        break;
    end
end
fprintf('--> Public key: (N,e) = (%d,%d)\n',N,e);
fprintf('--> Private key: d = %d\n',d);

% The exceeds of maximum integer that is guaranteed to be
% represented exactly as double (which is 2^53) can cause the incorrect result of
% Matlab mod() function -> Apply square-and-multiply algorithm to
% calculate modulo
fprintf('--> Encrypted ciphertext C of plaintext M = %d : C = %d\n',M,ModuloWithSaM(M,e,N));


----------------------------------------->> Function: RSADecryptionWithe.m <<---------------------------------------------

% LTNghia
% This is the function using RSA to calculate decryption if p,q,C and e is
% given

function RSADecryptionWithe(C,p,q,e)
N = p*q;
n = (p-1)*(q-1);
for i = 0:n
    if mod(e*i,n) == 1 % calculate the value of d so that e*d = 1 mod n
        d = i;
        break;
    end
end
fprintf('--> Public key: (N,e) = (%d,%d)\n',N,e);
fprintf('--> Private key: d = %d\n',d);

% The exceeds of maximum integer that is guaranteed to be
% represented exactly as double (which is 2^53) can cause the incorrect result of
% Matlab mod() function -> Apply square-and-multiply algorithm to
% calculate modulo
fprintf('--> Decrypted plaintext M of ciphertext C = %d : M = %d\n',C,ModuloWithSaM(C,d,N));


----------------------------------------->> Function: RSADecryptionWithd.m <<---------------------------------------------

% LTNghia
% This is the function using RSA to calculate decryption if p,q,C and d is
% given

function RSADecryptionWithd(C,p,q,d)
N = p*q;
n = (p-1)*(q-1);
for i = 0:n
    if mod(d*i,n) == 1 % calculate the value of e so that e*d = 1 mod n
        e = i;
        break;
    end
end
fprintf('--> Public key: (N,e) = (%d,%d)\n',N,e);
fprintf('--> Private key: d = %d\n',d);

% The exceeds of maximum integer that is guaranteed to be
% represented exactly as double (which is 2^53) can cause the incorrect result of
% Matlab mod() function -> Apply square-and-multiply algorithm to
% calculate modulo
fprintf('--> Decrypted plaintext M of ciphertext C = %d : M = %d\n',C,ModuloWithSaM(C,d,N));


----------------------------------------->> Script: assigment3script.m <<------------------------------------------------

% LTNghia

clc;

disp('------> This is the RSA script <------')
disp('Choose an option: ')
disp('1. Encrypt.')
disp('2. Decrypt.')
choice = input('Your choice is (e.g.,1,2,..): ');
if choice == 1
    disp('--> You are choosing Encrypt option.')
    disp('Choose an option: ')
    disp('1. e is given')
    disp('2. d is given')
    choice1 = input('Your choice is (e.g.,1,2,..): ');
    if choice1 == 1
        p = input('Enter the value of p: ');
        q = input('Enter the value of q: ');
        e = input('Enter the value of e: ');
        M = input('Enter the value of plaintext M: ');
        RSAEncryptionWithe(M,p,q,e);
    elseif choice1 == 2
        p = input('Enter the value of p: ');
        q = input('Enter the value of q: ');
        d = input('Enter the value of d: ');
        M = input('Enter the value of plaintext M: ');
        RSAEncryptionWithd(M,p,q,d);
    else 
        disp('--> Not a valid choice! Please re-run the script!')
    end
elseif choice == 2
    disp('--> You are choosing Decrypt option.')
    disp('Choose an option: ')
    disp('1. e is given')
    disp('2. d is given')
    choice2 = input('Your choice is (e.g.,1,2..): ');
    if choice2 == 1
        p = input('Enter the value of p: ');
        q = input('Enter the value of q: ');
        e = input('Enter the value of e: ');
        C = input('Enter the value of ciphertext C: ');
        RSADecryptionWithe(C,p,q,e);
    elseif choice2 == 2
        p = input('Enter the value of p: ');
        q = input('Enter the value of q: ');
        d = input('Enter the value of d: ');
        C = input('Enter the value of plaintext C: ');
        RSADecryptionWithd(C,p,q,d);
    else
        disp('--> Not a valid choice! Please re-run the script!')
    end
else 
    disp('--> Not a valid choice! Please re-run the script!')
end


** Note: I reused ModuloWithSaM function of assigment 2 for this assigment 3 


*************************************************** End of file **********************************************************